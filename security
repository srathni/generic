import streamlit as st
import pandas as pd

# Initialize session state for the number of rows
if 'num_rows' not in st.session_state:
    st.session_state.num_rows = 1

# Initialize session state to store text values as a dictionary of dictionaries
# Structure: {row_index: {col_name: value}}
if 'text_values' not in st.session_state:
    st.session_state.text_values = {}

# Define your columns here - you can customize these
COLUMNS = ["Name", "Email", "Phone"]  # Example columns
# Or you could make it configurable:
# COLUMNS = ["Column 1", "Column 2", "Column 3"]

st.title("Dynamic Multi-Column Text Input")

# Function to add a new row
def add_row():
    st.session_state.num_rows += 1

# Function to remove the last row
def remove_row():
    if st.session_state.num_rows > 1:
        # Remove the values for the last row
        row_to_remove = st.session_state.num_rows - 1
        if row_to_remove in st.session_state.text_values:
            del st.session_state.text_values[row_to_remove]
        st.session_state.num_rows -= 1

# Function to remove a specific row and reindex
def remove_specific_row(row_index):
    """Remove a specific row and reindex all subsequent rows"""
    if st.session_state.num_rows > 1:
        # Remove the specific row
        if row_index in st.session_state.text_values:
            del st.session_state.text_values[row_index]
        
        # Reindex all rows after the deleted row
        new_text_values = {}
        new_index = 0
        
        for old_index in range(st.session_state.num_rows):
            if old_index != row_index:  # Skip the deleted row
                if old_index in st.session_state.text_values:
                    new_text_values[new_index] = st.session_state.text_values[old_index]
                new_index += 1
        
        # Update session state
        st.session_state.text_values = new_text_values
        st.session_state.num_rows -= 1

st.write("---")

# Create the multi-column text inputs
for row in range(st.session_state.num_rows):
    # Create a container for each row
    row_container = st.container()
    
    with row_container:
        st.write(f"**Row {row + 1}:**")
        
        # Create columns for this row + one extra for delete button
        cols = st.columns(len(COLUMNS) + 1)
        
        # Initialize the row in text_values if it doesn't exist
        if row not in st.session_state.text_values:
            st.session_state.text_values[row] = {}
        
        # Create text inputs for each column
        for col_idx, col_name in enumerate(COLUMNS):
            with cols[col_idx]:
                # Get current value or empty string
                current_value = st.session_state.text_values[row].get(col_name, "")
                
                # Create unique key for this specific cell
                key = f"row_{row}_col_{col_name}"
                
                # Create the text input
                value = st.text_input(
                    col_name,
                    value=current_value,
                    key=key,
                    placeholder=f"Enter {col_name.lower()}"
                )
                
                # Store the value
                st.session_state.text_values[row][col_name] = value
        
        # Add delete button in the last column
        with cols[len(COLUMNS)]:
            st.write("")  # Empty space to align with text input height
            if st.session_state.num_rows > 1:  # Only show delete if more than 1 row
                if st.button("🗑️", key=f"delete_row_{row}", help="Delete this row"):
                    remove_specific_row(row)
                    st.rerun()
        
        # Add some spacing between rows
        if row < st.session_state.num_rows - 1:
            st.write("")

# Add the "+" button below all rows
st.write("")  # Add some space
plus_cols = st.columns(len(COLUMNS) + 1)
with plus_cols[len(COLUMNS)]:  # Position the + button in the same column as delete buttons
    if st.button("➕", help="Add new row"):
        add_row()
        st.rerun()

st.write("---")

# Display options
col1, col2, col3 = st.columns(3)

with col1:
    if st.button("Show All Values"):
        st.write("### Current Data:")
        
        # Create a list to store all rows for display
        display_data = []
        
        for row in range(st.session_state.num_rows):
            row_data = {}
            for col_name in COLUMNS:
                value = st.session_state.text_values.get(row, {}).get(col_name, "")
                row_data[col_name] = value
            display_data.append(row_data)
        
        # Display as a dataframe
        if display_data:
            df = pd.DataFrame(display_data)
            st.dataframe(df, use_container_width=True)

with col2:
    if st.button("Show as JSON"):
        st.write("### Data as JSON:")
        # Clean data (remove empty values)
        clean_data = {}
        for row in range(st.session_state.num_rows):
            row_data = {}
            for col_name in COLUMNS:
                value = st.session_state.text_values.get(row, {}).get(col_name, "")
                if value.strip():  # Only include non-empty values
                    row_data[col_name] = value
            if row_data:  # Only include rows with data
                clean_data[f"Row {row + 1}"] = row_data
        
        st.json(clean_data)

with col3:
    if st.button("Clear All"):
        st.session_state.text_values = {}
        st.rerun()

# Optional: Export functionality
st.write("---")
if st.button("Export to CSV"):
    # Create DataFrame from current data
    export_data = []
    for row in range(st.session_state.num_rows):
        row_data = {}
        for col_name in COLUMNS:
            value = st.session_state.text_values.get(row, {}).get(col_name, "")
            row_data[col_name] = value
        export_data.append(row_data)
    
    if export_data:
        df = pd.DataFrame(export_data)
        csv = df.to_csv(index=False)
        st.download_button(
            label="Download CSV",
            data=csv,
            file_name="multi_column_data.csv",
            mime="text/csv"
        )

# Show current session state for debugging (optional)
if st.checkbox("Show Debug Info"):
    st.write("Debug - Session State:")
    st.json({
        "num_rows": st.session_state.num_rows,
        "text_values": st.session_state.text_values
    })
