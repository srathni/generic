import streamlit as st
import pandas as pd

# Initialize session state for the number of rows
if 'num_rows' not in st.session_state:
    st.session_state.num_rows = 1

# Initialize session state to store text values as a dictionary of dictionaries
# Structure: {row_index: {col_name: value}}
if 'text_values' not in st.session_state:
    st.session_state.text_values = {}

# Define your columns here - you can customize these
COLUMNS = ["Name", "Email", "Phone"]  # Example columns
# Example with more columns to test width
# COLUMNS = ["First Name", "Last Name", "Email", "Phone", "Address", "City", "State", "ZIP Code"]

# Configuration for column widths and layout
MAX_COLUMNS_PER_ROW = 4  # Maximum columns before switching to vertical layout
USE_WIDE_MODE = True  # Use full width of the page

st.title("Dynamic Multi-Column Text Input")

# Apply wide mode if enabled
if USE_WIDE_MODE:
    st.set_page_config(layout="wide")

# Show current layout info
st.info(f"üìä Current setup: {len(COLUMNS)} columns | Wide mode: {'‚úÖ' if USE_WIDE_MODE else '‚ùå'} | Max per row: {MAX_COLUMNS_PER_ROW}")

# Function to add a new row
def add_row():
    st.session_state.num_rows += 1

# Function to remove the last row
def remove_row():
    if st.session_state.num_rows > 1:
        # Remove the values for the last row
        row_to_remove = st.session_state.num_rows - 1
        if row_to_remove in st.session_state.text_values:
            del st.session_state.text_values[row_to_remove]
        st.session_state.num_rows -= 1

# Function to remove a specific row and reindex
def remove_specific_row(row_index):
    """Remove a specific row and reindex all subsequent rows"""
    if st.session_state.num_rows > 1:
        # Remove the specific row
        if row_index in st.session_state.text_values:
            del st.session_state.text_values[row_index]
        
        # Reindex all rows after the deleted row
        new_text_values = {}
        new_index = 0
        
        for old_index in range(st.session_state.num_rows):
            if old_index != row_index:  # Skip the deleted row
                if old_index in st.session_state.text_values:
                    new_text_values[new_index] = st.session_state.text_values[old_index]
                new_index += 1
        
        # Update session state
        st.session_state.text_values = new_text_values
        st.session_state.num_rows -= 1

st.write("---")

# Create the multi-column text inputs
for row in range(st.session_state.num_rows):
    # Create a container for each row
    row_container = st.container()
    
    with row_container:
        st.write(f"**Row {row + 1}:**")
        
        # Initialize the row in text_values if it doesn't exist
        if row not in st.session_state.text_values:
            st.session_state.text_values[row] = {}
        
        # Decide layout based on number of columns
        if len(COLUMNS) <= MAX_COLUMNS_PER_ROW:
            # Horizontal layout - all columns in one row
            cols = st.columns(len(COLUMNS) + 1)  # +1 for delete button
            
            # Create text inputs for each column
            for col_idx, col_name in enumerate(COLUMNS):
                with cols[col_idx]:
                    # Get current value or empty string
                    current_value = st.session_state.text_values[row].get(col_name, "")
                    
                    # Create unique key for this specific cell
                    key = f"row_{row}_col_{col_name}"
                    
                    # Create the text input
                    value = st.text_input(
                        col_name,
                        value=current_value,
                        key=key,
                        placeholder=f"Enter {col_name.lower()}"
                    )
                    
                    # Store the value
                    st.session_state.text_values[row][col_name] = value
            
            # Add delete button in the last column
            with cols[len(COLUMNS)]:
                st.write("")  # Empty space to align with text input height
                if st.session_state.num_rows > 1:  # Only show delete if more than 1 row
                    if st.button("üóëÔ∏è", key=f"delete_row_{row}", help="Delete this row"):
                        remove_specific_row(row)
                        st.rerun()
        
        else:
            # Vertical layout - split into multiple rows for better width
            col_chunks = [COLUMNS[i:i + MAX_COLUMNS_PER_ROW] for i in range(0, len(COLUMNS), MAX_COLUMNS_PER_ROW)]
            
            for chunk_idx, chunk in enumerate(col_chunks):
                cols = st.columns(len(chunk))
                
                for col_idx, col_name in enumerate(chunk):
                    with cols[col_idx]:
                        # Get current value or empty string
                        current_value = st.session_state.text_values[row].get(col_name, "")
                        
                        # Create unique key for this specific cell
                        key = f"row_{row}_col_{col_name}"
                        
                        # Create the text input with wider appearance
                        value = st.text_input(
                            col_name,
                            value=current_value,
                            key=key,
                            placeholder=f"Enter {col_name.lower()}"
                        )
                        
                        # Store the value
                        st.session_state.text_values[row][col_name] = value
            
            # Add delete button on a separate line for vertical layout
            delete_col = st.columns([5, 1])
            with delete_col[1]:
                if st.session_state.num_rows > 1:  # Only show delete if more than 1 row
                    if st.button("üóëÔ∏è", key=f"delete_row_{row}", help="Delete this row"):
                        remove_specific_row(row)
                        st.rerun()
        
        # Add some spacing between rows
        if row < st.session_state.num_rows - 1:
            st.write("")

# Add the "+" button below all rows
st.write("")  # Add some space

if len(COLUMNS) <= MAX_COLUMNS_PER_ROW:
    # Horizontal layout - position + button in same column as delete buttons
    plus_cols = st.columns(len(COLUMNS) + 1)
    with plus_cols[len(COLUMNS)]:
        if st.button("‚ûï", help="Add new row"):
            add_row()
            st.rerun()
else:
    # Vertical layout - center the + button
    plus_col = st.columns([5, 1])
    with plus_col[1]:
        if st.button("‚ûï", help="Add new row"):
            add_row()
            st.rerun()

st.write("---")

# Display options
col1, col2, col3 = st.columns(3)

with col1:
    if st.button("Show All Values"):
        st.write("### Current Data:")
        
        # Create a list to store all rows for display
        display_data = []
        
        for row in range(st.session_state.num_rows):
            row_data = {}
            for col_name in COLUMNS:
                value = st.session_state.text_values.get(row, {}).get(col_name, "")
                row_data[col_name] = value
            display_data.append(row_data)
        
        # Display as a dataframe
        if display_data:
            df = pd.DataFrame(display_data)
            st.dataframe(df, use_container_width=True)

with col2:
    if st.button("Show as JSON"):
        st.write("### Data as JSON:")
        # Clean data (remove empty values)
        clean_data = {}
        for row in range(st.session_state.num_rows):
            row_data = {}
            for col_name in COLUMNS:
                value = st.session_state.text_values.get(row, {}).get(col_name, "")
                if value.strip():  # Only include non-empty values
                    row_data[col_name] = value
            if row_data:  # Only include rows with data
                clean_data[f"Row {row + 1}"] = row_data
        
        st.json(clean_data)

with col3:
    if st.button("Clear All"):
        st.session_state.text_values = {}
        st.rerun()

# Optional: Export functionality
st.write("---")
if st.button("Export to CSV"):
    # Create DataFrame from current data
    export_data = []
    for row in range(st.session_state.num_rows):
        row_data = {}
        for col_name in COLUMNS:
            value = st.session_state.text_values.get(row, {}).get(col_name, "")
            row_data[col_name] = value
        export_data.append(row_data)
    
    if export_data:
        df = pd.DataFrame(export_data)
        csv = df.to_csv(index=False)
        st.download_button(
            label="Download CSV",
            data=csv,
            file_name="multi_column_data.csv",
            mime="text/csv"
        )

# Show current session state for debugging (optional)
if st.checkbox("Show Debug Info"):
    st.write("Debug - Session State:")
    st.json({
        "num_rows": st.session_state.num_rows,
        "text_values": st.session_state.text_values
    })
